{"posts":[{"tags":["设计","ewigset"],"categories":["ewigset设计"],"title":"jointLearn设计","description":"大概流程: 初始化卡片，根据每张卡片的学习状态来判断jointLearn的状态。如果有未学习的卡片，就组装一轮卡片（每轮默认有7张卡片）。拆分考虑因素: 拆分速度......","url":"/posts/ewigset设计/jointLean设计.md","id":"3p0bqiok4tuoon8","image":"https://raw.githubusercontent.com/BenjaminFF/picbed/master/imgs/wide_figure6.jpg"},{"tags":["JavaScript","JS基础"],"categories":["JS基础"],"title":"bind和call的实现","description":"调用绑定函数时作为this参数传递给目标函数的值。 如果使用new运算符构造绑定函数，则忽略该值。当使用bind在setTimeout中创建一个函数（作为回调提供）时，作为thisArg传递的任何原始值都将转换为object。如果bind函数的参数列表为空，执行作用域的this将被视为......","url":"/posts/JS基础/bind和call的实现.md","id":"3p0bqiok4tuoon9","image":""},{"tags":["JavaScript","事件"],"categories":["JS基础"],"title":"JS事件","description":"事件处理函数可以附加在各种对象上，包括 DOM元素，window 对象 等。当事件发生时， event 对象就会被创建并依次传递给事件监听器。这种方式就是在一个元素上面直接绑定了一个点击onclick事件，此事件为DOM 0级标准。同时，这个事件的优先级......","url":"/posts/JS基础/事件.md","id":"3p0bqiok4tuoona","image":""},{"tags":["函数","JavaScript"],"categories":["JavaScript基础"],"title":"JS函数","description":"函数:对象类型的成员，标准内置构造器 Function 的一个实例，并且可做为子程序被调用。调用函数时，传给函数的值被称为函数的实参，对应位置的函数参数被称为形参。如果实参的值是一个原始类型，就算在函数内部改变了对应的形参值，函数执行完后，实参的值也不会......","url":"/posts/JS基础/函数.md","id":"3p0bqiok4tuoonb","image":""},{"tags":["运算符","JavaScript"],"categories":["JavaScript基础"],"title":"运算符和类型转换","description":"JavaScript 有两种比较方式：严格比较运算符和转换类型比较运算符。对于严格比较运算符（===）来说，仅当两个操作数的类型相同且值相等为 true，而对于被广泛使用的转换类型比较运算符（==）来说，会在进行比较之前，将两个操作数转换成......","url":"/posts/JS基础/运算符和类型转换.md","id":"3p0bqiok4tuoonc","image":""},{"tags":["JavaScript","原型","函数"],"categories":["JavaScript高级"],"title":"原型的思考","description":"对象(object): 对象类型的成员。当构造器创建一个对象，为了解决对象的属性引用，该对象会隐式引用构造器的“prototype”属性。通过程序表达式 constructor.prototype 可以引用到构造器的“prototype”属性，并且添加到对象原型里的属性，会通过继承与所有共享此原型的对象共享。另外，可使用 Object.create 内置函数，通过明确指定原型来创建一个新对象......","url":"/posts/JS高级/原型的思考.md","id":"3p0bqiok4tuoond","image":""},{"tags":["blog","spa","github"],"categories":["JavaScript","Github Page"],"title":"githubPages部署spa","description":"GitHub Pages原生不支持单页面应用。当这里有一个带有前端路由的新页面加载的时候(例如example.tld/foo)，因为/foo是前端路由，而GitHubPages服务器会把/foo作为后端路由来处理，因为在服务器找不到/foo这个路由所对应的文件，GitHubP......","url":"/posts/博客设计总结/githubPages部署spa.md","id":"3p0bqiok4tuoone","image":""},{"tags":["weixin"],"categories":["weixin","JavaScript"],"title":"微信小程序笔记","description":"网页开发渲染线程和脚本线程是互斥的，这也是为什么长时间的脚本运行可能会导致页面失去响应，而在小程序中，二者是分开的，分别运行在不同的线程中。网页开发者可以使用到各种浏览器暴露出来的 DOM API，进行 DOM 选中和操作。而如上文所述，小程序的逻辑层和渲染层是分开的，逻辑层运行在 JSCore 中，并没有一个完整浏览器对象，因而缺少相关的DOM API和BOM API。这一区别导致了前端开发非常熟悉的一些库，例如 jQuery、 Zepto 等，在小程序中是无法运行的。同时 JSCore 的环境同 NodeJS 环境也是不尽相同，所以一些 NPM 的包......","url":"/posts/小程序/微信小程序笔记.md","id":"3p0bqiok4tuoonf","image":""}],"mTags":["设计","ewigset","JavaScript","JS基础","事件","函数","运算符","原型","blog","spa","github","weixin"],"mCategories":["ewigset设计","JS基础","JavaScript基础","JavaScript高级","JavaScript","Github Page","weixin"]}