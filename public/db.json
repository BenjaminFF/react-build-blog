{
    "posts": [
        {
            "tags": [
                "设计",
                "ewigset"
            ],
            "categories": [
                "ewigset设计"
            ],
            "title": "jointLearn设计",
            "description": "大概流程: 初始化卡片，根据每张卡片的学习状态来判断jointLearn的状态。如果有未学习的卡片，就组装一轮卡片（每轮默认有7张卡片）。拆分考虑因素: 拆分速度......",
            "url": "/posts/ewigset设计/jointLean设计.md",
            "id": "3p0840wk4pkvt0a",
            "image": "./thumbnail.jpg"
        },
        {
            "tags": [
                "JavaScript",
                "JS基础"
            ],
            "categories": [
                "JS基础"
            ],
            "title": "bind和call的实现",
            "description": "调用绑定函数时作为this参数传递给目标函数的值。 如果使用new运算符构造绑定函数，则忽略该值。当使用bind在setTimeout中创建一个函数（作为回调提供）时，作为thisArg传递的任何原始值都将转换为object。如果bind函数的参数列表为空，执行作用域的this将被视为......",
            "url": "/posts/JS基础/bind和call的实现.md",
            "id": "3p0840wk4pkvt0b",
            "image": ""
        },
        {
            "tags": [
                "JavaScript",
                "事件"
            ],
            "categories": [
                "JS基础"
            ],
            "title": "JS事件",
            "description": "事件处理函数可以附加在各种对象上，包括 DOM元素，window 对象 等。当事件发生时， event 对象就会被创建并依次传递给事件监听器。这种方式就是在一个元素上面直接绑定了一个点击onclick事件，此事件为DOM 0级标准。同时，这个事件的优先级......",
            "url": "/posts/JS基础/事件.md",
            "id": "3p0840wk4pkvt0c",
            "image": ""
        },
        {
            "tags": [
                "函数",
                "JavaScript"
            ],
            "categories": [
                "JavaScript基础"
            ],
            "title": "JS函数",
            "description": "函数:对象类型的成员，标准内置构造器 Function 的一个实例，并且可做为子程序被调用。调用函数时，传给函数的值被称为函数的实参，对应位置的函数参数被称为形参。如果实参的值是一个原始类型，就算在函数内部改变了对应的形参值，函数执行完后，实参的值也不会......",
            "url": "/posts/JS基础/函数.md",
            "id": "3p0840wk4pkvt0d",
            "image": ""
        },
        {
            "tags": [
                "运算符",
                "JavaScript"
            ],
            "categories": [
                "JavaScript基础"
            ],
            "title": "运算符和类型转换",
            "description": "JavaScript 有两种比较方式：严格比较运算符和转换类型比较运算符。对于严格比较运算符（===）来说，仅当两个操作数的类型相同且值相等为 true，而对于被广泛使用的转换类型比较运算符（==）来说，会在进行比较之前，将两个操作数转换成......",
            "url": "/posts/JS基础/运算符和类型转换.md",
            "id": "3p0840wk4pkvt0e",
            "image": ""
        },
        {
            "tags": [
                "JavaScript",
                "原型",
                "函数"
            ],
            "categories": [
                "JavaScript高级"
            ],
            "title": "原型的思考",
            "description": "对象(object): 对象类型的成员。当构造器创建一个对象，为了解决对象的属性引用，该对象会隐式引用构造器的“prototype”属性。通过程序表达式 constructor.prototype 可以引用到构造器的“prototype”属性，并且添加到对象原型里的属性，会通过继承与所有共享此原型的对象共享。另外，可使用 Object.create 内置函数，通过明确指定原型来创建一个新对象......",
            "url": "/posts/JS高级/原型的思考.md",
            "id": "3p0840wk4pkvt0f",
            "image": ""
        },
        {
            "tags": [
                "weixin"
            ],
            "categories": [
                "weixin",
                "JavaScript"
            ],
            "title": "微信小程序笔记",
            "description": "网页开发渲染线程和脚本线程是互斥的，这也是为什么长时间的脚本运行可能会导致页面失去响应，而在小程序中，二者是分开的，分别运行在不同的线程中。网页开发者可以使用到各种浏览器暴露出来的 DOM API，进行 DOM 选中和操作。而如上文所述，小程序的逻辑层和渲染层是分开的，逻辑层运行在 JSCore 中，并没有一个完整浏览器对象，因而缺少相关的DOM API和BOM API。这一区别导致了前端开发非常熟悉的一些库，例如 jQuery、 Zepto 等，在小程序中是无法运行的。同时 JSCore 的环境同 NodeJS 环境也是不尽相同，所以一些 NPM 的包......",
            "url": "/posts/小程序/微信小程序笔记.md",
            "id": "3p0840wk4pkvt0g",
            "image": ""
        }
    ],
    "mTags": [
        "设计",
        "ewigset",
        "JavaScript",
        "JS基础",
        "事件",
        "函数",
        "运算符",
        "原型",
        "weixin"
    ],
    "mCategories": [
        "ewigset设计",
        "JS基础",
        "JavaScript基础",
        "JavaScript高级",
        "weixin",
        "JavaScript"
    ]
}